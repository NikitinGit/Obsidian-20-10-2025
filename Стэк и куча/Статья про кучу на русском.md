Анализ алгоритмов сборки мусора и управления памятью в Java P. Pufek, H. Grgić и B. Mihaljević Rochester Institute of Technology Croatia, Zagreb, Croatia paula.pufek@mail.rit.edu, hrvoje.grgic@mail.rit.edu, branko.mihaljevic@croatia.rit.edu

Аннотация – Значимыми элементами виртуальной машины Java (JVM), как части платформы Java, Standard Edition (Java SE), критически важными для автоматического управления памятью, являются различные алгоритмы сборки мусора (GC). Поскольку реализация Java Development Kit (JDK) постоянно совершенствуется, трудно игнорировать несколько новых предложений по улучшению Java (JEP), связанных с управлением памятью в JVM. Реализовано несколько различных сборщиков мусора в дополнение к существующим устаревшим алгоритмам последовательной, параллельной и параллельной пометки и уборки (CMS) сборки мусора, а также более новому GarbageFirst (G1) сборки мусора. Основным прогрессом с момента выхода JDK 10 является создание параллельной полной сборки мусора для G1 в качестве многопоточной сборки мусора по умолчанию при выполнении сборок на всей куче. Избыточные накладные расходы могут возникнуть, когда алгоритмы сборки мусора выполняют сборку мусора слишком часто, или может быть выделен слишком большой объем памяти, когда мусор не собирается регулярно. Целью функций новых алгоритмов является оптимизация общего процесса освобождения пространства, чтобы время пауз не влияло отрицательно на производительность приложений. В этой статье рассматриваются несколько сборщиков мусора, доступных в JDK 11, с использованием выбранных приложений для бенчмаркинга из набора DaCapo для сравнения количества итераций алгоритмов и продолжительности времени сборки. Ключевые слова – сборщик мусора; алгоритм сборки мусора; управление памятью; Java; G1; Garbage-First; DaCapo suite; Parallel Full GC для G1 I. ВВЕДЕНИЕ Управление памятью, процесс, который регулирует выделение и освобождение памяти для каждого приложения, должно быть оптимизировано для конкретного случая, чтобы работать эффективно. В языках программирования низкого уровня, например, языках C или C++, памятью явно управляет разработчик, что может впоследствии привести к тому, что приложение будет более подвержено ошибкам. Напротив, основная причина, по которой некоторые языки объектно-ориентированного программирования высокого уровня (ООП), такие как Java, отличаются от них, заключается в возможности выполнения автоматического освобождения и управления памятью. Важным компонентом абстрактной вычислительной машины со средой выполнения для других приложений, таких как Process Virtual Machine, является процесс автоматического управления памятью, достигаемый с помощью алгоритмов сборки мусора. Основными принципами системы автоматического управления памятью в Java Virtual Machine (JVM), встроенной части Java Runtime Environment (JRE), являются предоставление и восстановление необходимой памяти из объектов, которые больше не упоминаются в области памяти времени выполнения, называемой кучей. В современной разработке программного обеспечения автоматическая настройка освобождения памяти предпочтительнее ручной обработки перераспределения памяти, поскольку она помогает решить, какие части пространства кучи, где находятся созданные объекты, доступны для использования. Вместо того, чтобы полагаться на опыт разработчика с глубоким пониманием архитектуры областей данных времени выполнения, алгоритмы сборки мусора и другие внутренние оптимизации инструкций JVM [1], были встроены как часть среды выполнения, так и JVM. A. Память кучи Память кучи, определенная часть памяти, которая создается при запуске JVM, используется для выделения памяти всем экземплярам классов и массивам. Кроме того, все потоки JVM могут получать доступ к объектам, хранящимся в куче, и выполнять выделения, пока не будет достаточно места. Помимо кучи, как показано на рисунке 1, еще один важный элемент JVM вносит вклад в управление памятью, JIT-компиляция контролирует работающее приложение, отслеживая информацию и позволяет принимать решения на ее основе с целью оптимизации памяти [2]. B. Сборка мусора Компонент JVM, отвечающий за автоматический процесс управления памятью, часто называют сборкой мусора. Мусор, память кучи, которая больше не используется приложением, восстанавливается и повторно используется с помощью алгоритма Mark and Sweep, который является основным принципом алгоритмов сборки мусора. В своей простейшей форме этот алгоритм останавливает все запущенные потоки программы и проверяет все живые объекты, на которые есть ссылка в любом кадре стека любого потока приложения. После этого он просматривает дерево ссылок используемых объектов и помечает любой найденный объект как живой. Каждый оставшийся объект считается мусором и готов к сбору (очистке) [3]. Рисунок 1. Важнейшие компоненты виртуальной машины Java, связанные с управлением памятью MIPRO 2019, 20-24 мая 2019 г., Опатия, Хорватия 1677 Разрешенное лицензионное использование ограничено: Уральским федеральным университетом. Загружено 20 ноября 2024 г. в 19:25:26 UTC с IEEE Xplore. Действуют ограничения. Сборщик мусора отвечает за несколько задач [4], в том числе: выделение и возврат памяти y операционной системе Выдача этой памяти приложению по мере его запроса и определение того, какие части все еще используются приложением Освобождение неиспользуемой памяти для повторного использования приложением Суть сборки мусора Java заключается в том, что среда выполнения отслеживает объекты и автоматически уничтожает те, которые больше не нужны [2]. Однако сборщики мусора не решают всех проблем, связанных с автоматическим управлением памятью. Например, приложение может продолжать хранить ненужные ссылки или могут постоянно выделяться новые объекты, и, следовательно, может возникнуть ошибка нехватки памяти. Автоматическое освобождение связано с затратами на производительность, которые могут значительно увеличиваться при запуске приложений, которым может потребоваться больше вычислительных ресурсов [5]. Поэтому существует необходимость в улучшении алгоритмов сборки мусора, которые позволяют оптимизировать среду выполнения приложений таким образом, чтобы она редко прерывалась процессом сборки мусора [3]. Поэтому предлагаются новые усовершенствования, чтобы приблизиться к достижению этой цели. II. СБОРЩИКИ МУСОРА (GCS) Существует множество сборщиков мусора (GC), которые мы можем использовать в JVM, начиная от наиболее часто используемых старых GC, включая Serial GC, Parallel и Parallel Old GC, Concurrent Mark and Sweep (CMS) GC и Garbage-First (G1) GC, и заканчивая новейшими экспериментальными, такими как Z Garbage Collector (ZGC) и Shenandoah GC. Parallel Old GC был сборщиком мусора по умолчанию в JDK 7 и JDK 8, прежде чем он был заменен на G1 GC в JDK 9. G1 GC был улучшен с момента его официального представления и обновлен новым Parallel Full G1 GC, используемым по умолчанию в JDK 10 и более поздних версиях. Кроме того, в JDK 11 был представлен экспериментальный GC под названием Epsilon GC, в основном для целей тестирования. Более того, алгоритмом сборки мусора Java Zing VM по умолчанию является обновленный сборщик мусора Azul C4 (Continuously Concurrent Compacting Collector). A. Текущие сборщики мусора Java Последовательные, параллельные и параллельные Старые сборщики мусора реализованы как полные сборщики Stop-The-World (STW) и используют преимущество слабой гипотезы поколений, утверждающей, что подавляющее большинство объектов являются недолговечными, а другие имеют более длительный срок службы [2]. Следуя этой гипотезе, куча делится на три поколения: молодые, старые и постоянные. Сначала объекты выделяются в молодом поколении, и когда для новых объектов требуется больше памяти, выполняется второстепенная сборка мусора. Память, которая больше не используется, отбрасывается, а живые объекты перемещаются из молодого поколения в старое. Поскольку объекты в конечном итоге перемещаются, в какой-то момент времени необходимо собрать мусор во всей куче и, таким образом, выполнить полную сборку мусора, что может потребовать больше вычислительных ресурсов. Напротив, из-за сканирования неиспользуемых объектов без остановки запущенных потоков приложения, CMS и G1 GC известны как параллельные сборщики мусора с низкой паузой. Более того, оба могут выполнять полную сборку, но иногда стремятся избегать ее [6]. Приложение испытывает меньше пауз, поскольку длительность фаз, в которых останавливаются потоки приложения, уменьшается по сравнению с STW GC. Куча G1 GC основана на наборе регионов, в отличие от Parallel или CMS GC с кучей поколений. Начиная с JDK 9, CMS GC устарел, а G1 GC стал кучей по умолчанию. 1) Параллельный полный сбор мусора первым по порядку (PFG1) GC В сборке мусора первым по порядку и молодые, и старые поколения являются наборами регионов, и большинство операций по сборке мусора могут выполняться для каждого региона за раз, а не для всей кучи или целого поколения. Кроме того, нет необходимости заранее решать, какие регионы будут частью молодого или старого поколения; Таким образом, возможно, что после сборки мусора молодым поколением целый регион становится частью старого поколения и наоборот [7]. Хотя некоторые GC имеют генерационную конструкцию и относительно быстро завершают сборку на небольшой части кучи, им неизбежно приходится в какой-то момент времени входить в полную сборку, чтобы собрать все пространство кучи, и, таким образом, подвергаться значительным паузам. Полная сборка мусора использует алгоритм на основе уплотнения, который копирует все живые объекты в начало старого пространства, чтобы освободить огромную непрерывную свободную область памяти. В частности, Parallel Scavenge GC (PSGC), который совместим с Parallel Old GC, реализует полный алгоритм GC, который разбивает кучу на регионы, которые представляют задачи, назначенные нескольким потокам GC для дальнейшей параллельной обработки. Чтобы понять основные принципы полного алгоритма сбора, реализацию PSGC можно разделить на три фазы [8]: Фаза маркировки — потоки GC ищут живые объекты, например, ссылки в стеке или статические переменные из известных корней, которые помечаются как живые, а их местоположения записываются для последующего использования. Фаза сводки — PSGC вычисляет сводку кучи для всех живых объектов на основе предварительно сгенерированной реко rds, делит кучу на непрерывные регионы одинакового размера (по умолчанию 512 КБ) и суммирует объекты в пределах одного региона Фаза уплотнения — потоки GC одновременно извлекают регионы назначения и заполняют их найденными живыми объектами в соответствующих исходных регионах Иногда G1 GC не может найти свободный регион при попытке скопировать живые объекты из молодого региона или во время эвакуации из старого региона. В такие моменты сборщик попытается увеличить использование кучи, и если расширение пространства не удается, G1 активирует свой «отказоустойчивый» механизм, в котором один поток отмечает, очищает и уплотняет все регионы, составляющие поколения кучи [7]. Начиная с JDK 10, были некоторые улучшения относительно наихудших задержек G1 GC, что привело к 1678 Авторизованное лицензированное использование ограничено: Уральский федеральный университет. Загружено 20 ноября 2024 г. в 19:25:26 UTC с IEEE Xplore. Действуют ограничения. разработка Parallel Full GC для G1 GC1. Основным улучшением является многопоточный параллельный алгоритм mark-sweepcompact, который должен использовать то же количество потоков, что и молодые и смешанные сборки при выполнении полной сборки мусора. B. Экспериментальные и другие сборщики мусора За последние несколько лет было представлено несколько экспериментальных сборщиков мусора, но большинство из них все еще находятся в стадии разработки и используются только для специальных целей или в определенной среде. Epsilon GC 2 был представлен с последним JDK 11 как сборщик мусора, который обрабатывает выделения памяти, не выполняя никакого фактического освобождения памяти. Цель этого подхода заключается не в том, чтобы ввести функции ручного управления памятью в JVM или новый API управления кучей, а в том, чтобы использовать его в качестве точки отсчета для сравнений других сборщиков мусора при выполнении анализа производительности для других сборщиков мусора, тестирования памяти или виртуальной машины или для улучшения задержки и пропускной способности lastdrop. Это пассивная реализация GC с ограниченным пределом выделения и низкими издержками задержки за счет занимаемой памяти и пропускной способности. В некотором смысле Epsilon не является «настоящим» GC и предназначен только для целей тестирования или особых случаев. В рамках своей JVM Zing компания Azul Systems также создала высокопроизводительный параллельный и конкурирующий GC под названием C4 (Continuously Concurrent Compacting Collector) [9], который обеспечивает согласованное и ограниченное время отклика приложения, устраняя паузы GC, тем самым позволяя приложениям Java легче масштабироваться. Zing использует параллельное сжатие с одним 64-битным заголовком объекта word. Однако, поскольку C4 не является частью проекта с открытым исходным кодом, такого как OpenJDK, и нелегко сопоставим в нашей тестовой среде, мы не будем рассматривать его в этом анализе. В этой исследовательской работе мы также обсудим ZGC и Shenandoah GC, хотя оба они все еще считаются экспериментальными и находятся в стадии разработки. 1) Сборщик мусора Z ZGC 3 — это экспериментальный масштабируемый сборщик мусора с низкой задержкой, доступный в JDK 11. На момент написания этой статьи он доступен только для 64-битного Linux, который является его основной платформой, но другие платформы могут быть добавлены позже. Он обрабатывает кучи от относительно небольших до очень больших многотерабайтных размеров, и время паузы ZGC не увеличивается с размером кучи или живого набора. Таким образом, куча может варьироваться от ГБ до ТБ, и это не окажет существенного влияния на время паузы, поскольку фазы STW ограничены сканированием корня, а время его паузы не должно превышать 10 мс. По сравнению с G1, ZGC также основан на регионах, но имеет гибкую схему размеров и лучший способ работы с 1 JEP 307: Параллельный полный GC для G1, http://openjdk.java.net/jeps/307 2 JEP 318: Epsilon: Неработающий сборщик мусора (экспериментальный) https://openjdk.java.net/jeps/318 3 JEP 333: ZGC: Масштабируемый сборщик мусора с малой задержкой (экспериментальный), https://openjdk.java.net/jeps/333 выделением объектов; нет разделения поколений кучи. Куча внутренне разделена на множество небольших регионов, и мы можем выбрать для сжатия подмножество из них, обычно то, которое содержит больше всего мусора. Барьеры нагрузки и цветные указатели — два основных метода, выбранных для достижения параллелизма в ZGC. Раскрашивание указателей — это основной метод, который хранит метаданные в неиспользуемых битах 64-битных указателей. Поскольку в 32-битных указателях недостаточно неиспользуемого пространства для использования раскрашивания указателей, 32-битные платформы в настоящее время не поддерживают ZGC. Метаданные содержат информацию о самом объекте или об объекте, на который они указывают, и в настоящее время они хранят информацию, связанную с маркировкой и перемещением. Сохраняя метаданные в указателе, мы можем использовать барьер загрузки, когда ссылка на объект должна быть загружена из кучи, что концептуально похоже на декодирование сжатых Oops (обычных указателей объектов). После загрузки ссылки барьер загрузки проверит, являются ли биты метаданных (т. е. цвета) «хорошими» или «плохими», и примет решение. «Плохой» цвет означает, что должно быть выполнено определенное действие, будь то маркировка, перемещение или переназначение (в зависимости от фазы GC), а «хороший» цвет или указывает на то, что нет необходимости снова загружать ссылку на объект из кучи [10]. Цветные указатели позволяют повторно использовать память до того, как освобожденные регионы будут зафиксированы во время фазы уплотнения перемещения, что помогает снизить общие накладные расходы на кучу, и, следовательно, не требуется реализовывать дополнительный отдельный алгоритм пометки-сжатия, который должен обрабатывать полные коллекции. Кроме того, всего несколько простых барьеров GC снижают накладные расходы во время выполнения и обеспечивают более простую реализацию, оптимизацию и обслуживание кода барьера GC в интерпретаторе и JIT-компиляторах 3 . 2) Сборщик мусора Shenandoah Основной причиной разработки экспериментального Shenandoah GC 4 компанией Red Hat было сокращение времени паузы за счет выполнения параллельного уплотнения. Shenandoah GC [11] — это параллельный и параллельный сборщик мусора с открытым исходным кодом на основе регионов с низкой паузой, похожий на ZGC, который пытается сократить время паузы за счет эвакуации объектов (уплотнения) одновременно с запущенными потоками приложения. Хотя производительность GC зависит от размера кучи, в Shenandoah время паузы не зависит от размера кучи. Параллельное уплотнение является сложной задачей, как и при перемещении живых объектов, все ссылки на этот объект должны быть обновлены, чтобы указывать на новое местоположение, и чтобы найти эти ссылки, необходимо просканировать всю кучу. Макет объекта для Shenandoah GC добавляет свое слово в заголовок каждого объекта, и оно выделяется только при использовании этого сборщика. Это позволяет перемещать объекты без обновления всех ссылок объекта, но поток, копирующий объект, выполняет атомарное сравнение и обмен, чтобы он указывал на новый адрес. Все будущие чтения или записи на этом объекте будут выполняться на пересылаемой копии через указатель пересылки. Подобно ZGC, куча Shenandoah составляет 4 JEP 189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental), https://openjdk.java.net/jeps/189 1679 Разрешенное лицензионное использование ограничено: Уральский федеральный университет. Загружено 20 ноября 2024 г. в 19:25:26 UTC с IEEE Xplore. Действуют ограничения. разделена на области одинакового размера, и область может содержать недавно выделенные объекты, долгоживущие объекты или смесь того и другого, и любое подмножество этих областей может быть собрано во время цикла GC, аналогично G1. III. ТЕСТИРОВАНИЕ И ПРЕДВАРИТЕЛЬНЫЕ РЕЗУЛЬТАТЫ A. Набор тестов Тестовые наборы — это практические исследовательские инструменты, незаменимые при тестировании качества функций систем, которые сообщают описательные результаты для демонстрации преимуществ новой или улучшенной системы [12]. Для целей данного исследования мы выбрали набор DaCapo 5, который состоит из набора реальных приложений Java для анализа производительности и управления памятью с нетривиальными нагрузками на память. В общем случае тесты DaCapo с открытым исходным кодом в основном больше, сложнее и богаче, чем обычно используемые тесты SPEC Java, поэтому они идеально подходят для научных оценок [13]. Для изучения характеристик новых и экспериментальных GC, доступных в JDK 11, мы решили использовать версию 9.12-bach набора тестов DaCapo, который также использовался, когда проводилось наше предыдущее предварительное исследование, и G1 GC сравнивался со сборщиками мусора в JDK 9 [14]. Выбранный набор тестовых приложений аналогичен тем, которые использовались в предыдущем тестировании, и включает следующие тесты: fop (однопоточное приложение, которое анализирует XSL-FO для генерации PDF), h2 (многопоточная база данных в памяти, которая выполняет JDBC, выполняя транзакции по банковской модели), pmd (приложение, которое анализирует исходный код Java в нескольких потоках), xalan (преобразует XML-документы в HTML, используя несколько потоков), sunflow (многопоточная система рендеринга для реалистичных изображений с использованием трассировки лучей) и tradebeans (производный бенчмарк Daytrader с несколькими потоками). B. Тестовая среда Наша тестовая среда основана на Java HotSpotTM Client VM сборки 25.201-b09, смешанный режим, а также Java HotSpot 64-Bit Server VM 18.9 сборки 11.0.2+7- LTS, смешанный режим. Кроме того, была включена виртуальная машина OpenJDK 64-Bit Server VM сборки 12-ea+29, смешанный режим и совместное использование. Средой хостинга, которая обеспечивала тестирование, была ОС Windows 10 Pro. Что касается освобождения памяти, то выбором JVM для GC в JDK 8 был Parallel GC, тогда как в JDK 11 был выбран G1 GC. Кроме того, были протестированы другие алгоритмы сборки мусора, включая CMS и Serial GC. Результаты были собраны с помощью графического инструмента Visual VM6 версии 1.4.2, а также его плагина Visual GC, который позволяет проводить углубленное исследование измерений как количества коллекций алгоритмов, так и продолжительности каждой. Мы повторили каждый тестовый сценарий в трех различных версиях Java. Более того, каждый случай состоял из пяти независимых итераций среды выполнения приложения, и были рассчитаны как средняя продолжительность, так и количество коллекций. Кроме того, размер живого набора определялся в каждой среде выполнения путем установки размера кучи в 1 ГБ. 5 Тесты DaCapo, http://dacapobench.org/ 6 Visual VM, https://visualvm.github.io/ C. Предварительные результаты На основе сгенерированных трассировок были извлечены метрики, т. е. количество сборок, а также продолжительность выполнения, для выбранных тестовых случаев в JDK 8 и JDK 11, а также в сборке OpenJDK 12 Early-Access. Несмотря на то, что ожидалось, что G1 GC будет работать лучше в большинстве тестов, это не всегда так, и преимущества G1 не были явно представлены в предварительных результатах в JDK 8. Однако при глубоком изучении собранных данных интересные улучшения в производительности G1 и Parallel GC могут быть заметны в более новых версиях Java. В JDK 8 продолжительность сборок G1 больше по сравнению с Parallel GC для каждого приложения, за исключением tradebeans (рисунок 2). При сравнении этих результатов с Serial GC, количество сборок (рисунок 3) больше похоже на Parallel GC, тогда как в большинстве случаев время выполнения отличается, поскольку оно увеличивается по сравнению как с G1, так и с Parallel GC. Кроме того, для других выбранных приложений, за исключением fop и h2, сборщик CMS выполнил больше сборок, чем другие сборщики, за относительно более длительный период, чем G1 и Parallel GC. Рисунок 2. Сравнение продолжительности (в миллисекундах) сборок в JDK 8 для выбранных приложений для тестирования DaCapo Рисунок 3. Сравнение количества сборок в JDK 8 для выбранных приложений для тестирования DaCapo После проведения идентичного теста в JDK 11 поведение упомянутых алгоритмов изменилось. Наиболее интересная разница видна в общем времени сборки мусора сборок G1 и Parallel GC, когда G1 был быстрее, фактически, для приложения pmd даже почти в два раза быстрее, чем Parallel GC (рисунок 4), но в большинстве случаев Parallel GC выполнил больше сборок, чем G1 (рисунок 5). Однако для тестового случая h2 можно обнаружить основное уменьшение времени сборки G1 в JDK 11, т. е. новый Parallel Full G1 выполняет такое же количество сборок, как в JDK 8, но с заметно меньшей продолжительностью. 0 200 400 600 800 1000 1200 1400 fop h2 pmd xalan sunflow tradebeans Время в миллисекундах G1 GC Parallel GC Serial GC CMS GC 1680 Разрешенное лицензионное использование ограничено: Уральский федеральный университет. Загружено 20 ноября 2024 г. в 19:25:26 UTC с IEEE Xplore. Действуют ограничения. Рисунок 4. Сравнение продолжительности (в миллисекундах) сборок в JDK 11 для выбранных тестовых приложений DaCapo Рисунок 5. Сравнение количества сборок в JDK 11 для выбранных тестовых приложений DaCapo Кроме того, помимо того, что G1 превзошел Parallel GC в случае pmd, можно заметить еще одно интересное различие в поведении G1 в случае приложения xalan по сравнению с Parallel GC. У G1 было на 13,34% меньше сборок, но за вдвое меньшее время, тогда как в JDK 8 Parallel GC, безусловно, был лучшим выбором для xalan. Наблюдение в случае бенчмарка fop заключается в том, что G1 выполнил больше операций, чем Parallel GC, поскольку во всех других случаях Parallel GC выполнил большее количество сборок, например, для приложения sunflow на 44,74% больше, а для tradebeans это число значительно увеличилось. Кроме того, для бенчмарка sunflow Parallel GC превосходит G1, поскольку он выполнил почти в два раза больше сборок с немного сокращенным временем выполнения в JDK 8, а в JDK 11 как сборка, так и длительность пропорциональны, а также увеличены для обоих сборщиков. С довольно интересным результатом в случае fop, где G1 показал превосходство над другими сборщиками в результате увеличенного количества сборок, другой бенчмарк luindex был включен в качестве части тестирования, поскольку и fop, и luindex работают в одном потоке. Luindex — это однопоточная библиотека полнотекстового поиска, имеющая низкий показатель выживаемости питомника (мера того, насколько близко программа следует гипотезе поколений). Более того, он имеет высокий коэффициент оборота кучи, что может предполагать существенную рабочую нагрузку GC [13]. Однако только G1 смог выполнить сборку в такой среде с положительным результатом, так как, например, Parallel GC смог выполнить 10 сборок примерно за 130 миллисекунд при исключении аргумента –no-pre-iteration-gc, который сообщил о худшей производительности Parallel GC по сравнению с G1 GC из-за архитектуры кучи на основе регионов G1. Хотя можно сделать вывод, что G1 и Parallel GC являются основными конкурентами для некоторых тестовых случаев, есть также показатели того, что иногда лучшим сборщиком с точки зрения оптимизации является CMS GC, что является редким случаем в наших результатах. Например, в случае xalan, CMS, безусловно, является лучшим выбором, но, принимая во внимание, что он устарел, Serial collector является предпочтительным выбором для xalan, а не G1 или Parallel GC. Однако, что касается оптимального количества затраченного времени, мы считаем G1 GC лучшим вариантом по сравнению с другими коллекторами в этом случае. Напротив, за исключением CMS, лучшим коллектором для sunflow является Parallel GC с коротким время выполнения теста. Важно отметить, что sunflow является одним из самых интенсивно выделяющих бенчмарков и может выделять до 134 ГБ соответственно. Цифры, демонстрирующие поведение сборщиков мусора в предстоящем JDK 12, не сильно отличаются от JDK 11. Однако при более внимательном рассмотрении Parallel GC выполнил меньше операций в случае pmd за более короткий период, чем в JDK 11. Кроме того, общее время сборки G1 в этом случае было короче. Интересное различие можно увидеть также в поведении CMS и Serial при измерении количества сборок, которое похоже на JDK 11, но общее время сборки мусора почти вдвое сокращается для Serial и заметно увеличивается, когда CMS использовалась для выполнения сборки для pmd. Как показано (рисунок 6 и рисунок 7), общая продолжительность времени для G1 значительно сократилась с JDK 8. Также ясно видно, что Parallel был лучшим вариантом для pmd (рисунок 8) до выпуска Java 11, в котором G1 показал лучшее поведение, чем Parallel GC, хотя в JDK 12 время выполнения Parallel заметно сократилось. Аналогично, при использовании алгоритмов в другом бенчмарке, т. е. tradebeans, во всех версиях Java G1 показал себя наилучшим образом и сократил общее время сбора с момента своего первого выпуска. Рисунок 6. Сравнение продолжительности (в миллисекундах) сборок в JDK 12 для выбранных тестовых приложений DaCapo Рисунок 7. Сравнение количества сборок в JDK 12 для выбранных тестовых приложений DaCapo 1681 Разрешенное лицензионное использование ограничено: Уральским федеральным университетом. Загружено 20 ноября 2024 г. в 19:25:26 UTC с IEEE Xplore. Действуют ограничения. Рисунок 8. Общее время выполнения для бенчмарка pmd IV. ОБСУЖДЕНИЕ На протяжении всей истории Java алгоритмы сборки мусора утомительно переанализировались для достижения среды, в которой GC работают оптимально. По словам П. Ленгауэра, В. Битто, Х. Мёссенбёка и М. Венингера [12], незначительное время паузы G1 составляет всего 71% от времени паузы ParallelOld GC, например, время паузы приложения h2 составляет 300 мс с ParallelOld GC и всего 81 мс с GC G1, что в основном связано со способностью G1 выбирать регионы, которые будут собраны, и, как следствие, контролировать время паузы, а также количество регионов, в которых будет освобождена память. Производительность G1 и Parallel GC в JDK 8 и 11 была протестирована на бенчмарках OptaPlanner [15]. Поскольку Parallel GC ориентирован на пропускную способность, тогда как основная цель G1 — низкая задержка, Parallel GC по-прежнему является лучшим сборщиком для OptaPlanner с точки зрения оптимизации согласно результатам. Однако почти для каждого заданного набора данных средний процент улучшения G1 в Java 11 составляет 16%, что может быть поддержано недавно представленной Parallel Full Garbage Collection с несколькими потоками. Учитывая тот факт, что новые экспериментальные алгоритмы GC были введены в новых версиях Java, уже существующие сборщики также сравнивались с Shenandoah GC путем запуска бенчмарков DaCapo [11], и в 7 из 11 тестовых случаев общая продолжительность времени G1 была уменьшена или равна Shenandoah GC. Однако при измерении производительности Shenandoah и других сборщиков мусора, то есть G1, Parallel и CMS GC, с помощью бенчмарка, стимулирующего реальное клиентское приложение, у Shenandoah было заметно меньше пауз GC по сравнению с другими алгоритмами. V. ЗАКЛЮЧЕНИЕ Хотя могут быть условия, например, приложение, работающее с несколькими или, скорее, с одним потоком, которые могут повлиять на производительность алгоритма, в реализациях алгоритмов сборки мусора можно увидеть заметные изменения. G1 работал лучше или таким же образом, как Parallel GC в случаях h2, pmd, xalan и tradebeans, учитывая общую продолжительность итераций в последней версии Java. Однако CMS и Serial не представили никаких убедительных доказательств, которые помешали бы нам усомниться в его прочной позиции за последние годы, но они не показали, что они определенно превосходят G1 и Parallel GC. Поэтому с улучшенным G1 он, безусловно, представляет направление, в котором движутся будущие GC. Мы считаем, что будущие экспериментальные GC также внесут вклад в оптимизацию систем в целом. Будет полезно изучить усовершенствования, которые неизбежно принесут пользу тем средам, в которых указанный GC управляет памятью без дополнительных барьеров, которые могли бы снизить производительность приложения.