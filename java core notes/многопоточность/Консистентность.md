Причиной нарушения консистентности может быть кэширование проца. 
Ключевое слово  **`volatile`** указываает на то, что переменную нельзя брать из кэша, а надо брать из основной памяти минуя кэш.
Если один поток только читает volatile , а второй только меняет, то конистентн
гарантированна , но если оба меняют -  то нет - 
### ПРОВЕРЬ 


### VOLATILE https://jenkov.com/tutorials/java-concurrency/volatile.html 

https://habr.com/ru/articles/354748/ 

1. **Кэширование и локальные переменные**:
    
    - Когда потоки работают с локальными переменными, каждый поток может хранить копии этих переменных в своем собственном кэше (например, L1). Если один поток изменяет значение переменной, другие потоки могут не увидеть это изменение, если они используют устаревшую версию переменной из своего кэша.
    
2. **Протоколы когерентности кэша**:
    
    - Современные процессоры используют протоколы когерентности кэша (например, MESI), которые обеспечивают согласованность данных между кэшами различных ядер. Эти протоколы помогают синхронизировать изменения данных, но могут вводить задержки при доступе к данным, что может повлиять на производительность.
    
3. **Использование `volatile`**:
    
    - В Java использование ключевого слова `volatile` для переменных позволяет избежать проблем с кэшированием. При объявлении переменной как `volatile` все операции чтения и записи будут происходить непосредственно из основной памяти, минуя кэш. Это гарантирует, что все потоки видят актуальное значение переменной.
    
4. **Проблемы производительности**:
    
    - Если данные часто изменяются и доступны из разных потоков, это может привести к частым сбросам кэша и синхронизации между ядрами, что ухудшает производительность приложения.


На практике значения регистров процессора обычно просто записываются в кэш L1 процессора, что достаточно быстро. Не так быстро, как запись в регистр процессора, но все же быстро. Синхронизация из кэша L1 вниз через кэш L2 и L3 и обратно в основную память (RAM) выполняется отдельными чипами, а не процессором (насколько я понимаю), так что процессор этим не обременен.

Но даже в этом случае старайтесь использовать летучие переменные только тогда, когда они вам действительно нужны. Это также заставит вас детально разобраться в том, как работают волатильные переменные в Java!

Переведено с помощью DeepL.com (бесплатная версия)