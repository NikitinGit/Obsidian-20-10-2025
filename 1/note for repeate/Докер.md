>[!question]- как написать 2 докер файла java приложения, использующих один jdk
>Пиши

>[!question]- Что такое VOLUME в докерфайле
>Том - пиши

>[!question]- Где может находится докер файл
>Пиши

>[!question]- Docker Swarm это 

>[!question]- отличие образа от вируальной среды типа virtualBox
>докер использует ядро хостовой ОС , меньше весит изоляция тольк она уровне процессов и файловой системы а не полная изоляция со своим ядром как в виртуалбокс

>[!question]- Что делает команда FROM  в докерфайле
>СКАЧИВАЕТ образ из докер хаба
>Команда `FROM` указывает **базовый слой**, на котором будет построен твой образ.

>[!question]- Создать образ - самый простой пример
>1. создать докер файл 
>```  
>FROM openjdk:17-jdk-slim  
>VOLUME /tmp  
>COPY target/service2-0.0.1-SNAPSHOT.jar service2-0.0.1-SNAPSHOT.jar  
>ENTRYPOINT ["java","-jar","/service2-0.0.1-SNAPSHOT.jar"]  
>```
>2. Создать образ
>docker build -t service1 .

>[!question]- запустить образ
>docker run -d -p 8080:8080 --name my-service1 service1

>[!question]- перезапустить образ
>docker stop id
>docker rm id
>docker run -d -p 8081:8080 --name my-service1 service1

>[!question]-  Что означает запись 8082:8080
>8082 - порт на котором слушает контейнер
>8000 - порт на который контейнер перенаправляет полученный запрос

>[!question]- ENTRYPOINT это
>инструкция по запуску контейнера 

>[!question]- подключиться к БД серверу если он запущен в докере
>Подключение к контейнеру
>docker exec -it f28 mysql -u root -p
>создание БД
>CREATE DATABASE service_db1;

>[!question]- смотреть логи в рилтайме
>docker logs -f 1f1 

>[!question]- Удаление контейнера
>Перед удалением надо остановить контейнер docker stop idContainer
>docker rm idContainer
>Принудительно удалить колнтейнер
>docker rm -f idContainer   ----  (if = forse)
>Проверить что контейнер удален
>docker ps -a | grep nginx-proxy  

>[!question]- удалить образы
>```
>for image_id in $IMAGE_IDS; do     echo "Удаление контейнеров для образа: $image_id";     docker rm -f $(docker ps -a -q --filter "ancestor=$image_id") 2>/dev/null || true; done
>docker rmi -f e7af48eb40e0 594b307bda62 21333ca8662c
>```


# **DOCKER COMPOSE**
>[!question]- Что такое volumes
>Том - пиши

>[!question]- depends_on это 
>указатель на то, что один контейнер зависит от другого, управляет порядком запуска контейнеров но не их готовностью , например 
>```
>depends_on:
>  mysql:
>    condition: service_healthy
>```
>ждет когда запуститься mysql и будет здоров - service_healthy

>[!question]- healthcheck
>```
>healthcheck:
  test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-pgtngtngtnN5"]
  interval: 5s
  timeout: 5s
  retries: 10 - после 10 попыток помечается как не здоров при docker ps
>```
>test - команда, которую докер будет выполнять пока не получит от контейнера ответа что он уже жив

>[!question]- На что указывает version: '3'
>Это не версия **Docker Compose** как утилиты, а **версия формата конфигурации** (schema version), которую использует сам Docker Compose для интерпретации файла

>[!question]- Самый простой пример микросервисного docker-compose.yml
>```yaml
>version: '3'
>services:
>  service1:
>    image: service1
>    ports:
>      - "8081:8080"
>
>  service2:
>    image: service2
>    ports:
>      - "8082:8080"
>```

>[!question]- ЗАПУСТИТЬ 
>**Cоздать в директории docker-compose.yml**
>с просмотром логов в реальном времени 
>docker-compose up 
>в фоновом режиме 
>docker-compose up -d
>Запуск с принудительной пересборкой образов
> docker-compose up -d --build
>
>**Если файл не один в проекте то ЗАПУСК ПО ИМЕНИ  **
>Запуск с принудительной пересборкой образов 
>docker-compose -f docker-compose-database.yml up --build

>[!question]- Пересобрать и запустить
>**Остановка и удаление контейнеров, сетей (но не volumes)**
>docker-compose down
>**Если нужно удалить и volumes (осторожно! данные будут потеряны)** 
  docker-compose down -v
>**Пересборка всех сервисов**
  docker-compose build

>[!question]- Удалить созданные им образы
>docker-compose down --rmi all
  
>[!question]- смотреть логи в рилтайме
>одного котейнера
>docker-compose logs -f 1f1 
>всех контейнеров
> docker-compose logs -f  

>[!question]- Указать путь к докерфайлу
> в секции servises: my-service написать 
> context: /home/user/path
> dockerfile: Dockerfile
# ФЛАГИ
В разных командах флаги имеют разное значение 
>[!question]- docker exec -it
>Выполнить команду внутри контейнера
>**(--tty)** - выделяет псевдо-терминал для сессии

>[!question]- docker build -t service1 .
> -t устанавливает имя образу
> . указывает на текущую директорию, где находится Dockerfile и файлы для сборки

>[!question]- -d
>запуск контейнера в фоновом режиме detached mode
