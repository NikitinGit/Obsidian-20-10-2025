>[!question]- как написать 2 докер файла java приложения, использующих один jdk
>Пиши

>[!question]- отличие образа от вируальной среды типа virtualBox
>пиши

>[!question]- Создать образ - самый простой пример
>1. создать докер файл 
>```  
>FROM openjdk:17-jdk-slim  
>VOLUME /tmp  
>COPY target/service2-0.0.1-SNAPSHOT.jar service2-0.0.1-SNAPSHOT.jar  
>ENTRYPOINT ["java","-jar","/service2-0.0.1-SNAPSHOT.jar"]  
>```
>2. Создать образ
>docker build -t service1 .

>[!question]- запустить образ
>docker run -d -p 8080:8080 --name my-service1 service1

>[!question]- перезапустить образ
>docker stop id
>docker rm id
>docker run -d -p 8081:8080 --name my-service1 service1

>[!question]-  Что означает запись 8082:8080
>8082 - порт на котором слушает контейнер
>8000 - порт на который контейнер перенаправляет полученный запрос

>[!question]- ENTRYPOINT это
>инструкция по запуску контейнера 

>[!question]- подключиться к БД серверу если он запущен в докере
>Подключение к контейнеру
>docker exec -it f28 mysql -u root -p
>создание БД
>CREATE DATABASE service_db1;

>[!question]- смотреть логи в рилтайме
>docker logs -f 1f1 

>[!question]- Удаление контейнера
>Перед удалением надо остановить контейнер docker stop idContainer
>docker rm idContainer
>Принудительно удалить колнтейнер
>docker rm -f idContainer   ----  (if = forse)
>Проверить что контейнер удален
>docker ps -a | grep nginx-proxy  

>[!question]- удалить образы
>```
>for image_id in $IMAGE_IDS; do     echo "Удаление контейнеров для образа: $image_id";     docker rm -f $(docker ps -a -q --filter "ancestor=$image_id") 2>/dev/null || true; done
>docker rmi -f e7af48eb40e0 594b307bda62 21333ca8662c
>```


# **DOCKER COMPOSE**
>[!question]- Самый простой пример микросервисного docker-compose.yml
>```yaml
>version: '3'
>services:
>  service1:
>    image: service1
>    ports:
>      - "8081:8080"
>
>  service2:
>    image: service2
>    ports:
>      - "8082:8080"
>```

>[!question]- ЗАПУСТИТЬ 
>**Cоздать в директории docker-compose.yml**
>с просмотром логов в реальном времени 
>docker-compose up 
>в фоновом режиме 
>docker-compose up -d
>Запуск с принудительной пересборкой образов
  docker-compose up -d --build

>[!question]- Пересобрать и запустить
>**Остановка и удаление контейнеров, сетей (но не volumes)**
>docker-compose down
>**Если нужно удалить и volumes (осторожно! данные будут потеряны)** 
  docker-compose down -v
>**Пересборка всех сервисов**
  docker-compose build

>[!question]- Удалить созданные им образы
>docker-compose down --rmi all
  
>[!question]- смотреть логи в рилтайме
>одного котейнера
>docker-compose logs -f 1f1 
>всех контейнеров
> docker-compose logs -f  

>[!question]- Указать путь к докерфайлу
> в секции servises: my-service написать 
> context: /home/user/path
> dockerfile: Dockerfile
# ФЛАГИ
В разных командах флаги имеют разное значение 
>[!question]- docker exec -it
>**(--tty)** - выделяет псевдо-терминал для сессии

>[!question]- docker build -t service1 .
> -t устанавливает имя образу
> . указывает на текущую директорию, где находится Dockerfile и файлы для сборки

>[!question]- -d
>запуск контейнера в фоновом режиме detached mode
